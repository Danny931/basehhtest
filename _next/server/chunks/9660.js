"use strict";
exports.id = 9660;
exports.ids = [9660];
exports.modules = {

/***/ 51642:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _pancakeswap_multicall__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(82547);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    masterChef: {
        97: "0xB4A466911556e39210a6bB2FaECBB59E4eB7E43d",
        56: "0xa5f8C5Dbd5F286960b9d90548680aE5ebFf07652"
    },
    masterChefV1: {
        97: "0x1d32c2945C8FDCBc7156c553B7cEa4325a17f4f9",
        56: "0x73feaa1eE314F8c655E354234017bE2193C9E24E"
    },
    sousChef: {
        97: "0xd3af5fe61dbaf8f73149bfcfa9fb653ff096029a",
        56: "0x6ab8463a4185b80905e05a9ff80a2d6b714b9e95"
    },
    lotteryV2: {
        97: "0x5790c3534F30437641541a0FA04C992799602998",
        56: "0x5aF6D33DE2ccEC94efb1bDF8f92Bd58085432d2c"
    },
    multiCall: _pancakeswap_multicall__WEBPACK_IMPORTED_MODULE_0__/* .multicallAddresses */ .dl,
    pancakeProfile: {
        56: "0xDf4dBf6536201370F95e06A0F8a7a70fE40E388a",
        97: "0x4B683C7E13B6d5D7fd1FeA9530F451954c1A7c8A"
    },
    pancakeBunnies: {
        56: "0xDf7952B35f24aCF7fC0487D01c8d5690a60DBa07",
        97: "0x60935F36e4631F73f0f407e68642144e07aC7f5E"
    },
    bunnyFactory: {
        56: "0xfa249Caa1D16f75fa159F7DFBAc0cC5EaB48CeFf",
        97: "0x707CBF373175fdB601D34eeBF2Cf665d08f01148"
    },
    claimRefund: {
        56: "0xE7e53A7e9E3Cf6b840f167eF69519175c497e149",
        97: ""
    },
    pointCenterIfo: {
        56: "0x3C6919b132462C1FEc572c6300E83191f4F0012a",
        97: "0xd2Ac1B1728Bb1C11ae02AB6e75B76Ae41A2997e3"
    },
    bunnySpecial: {
        56: "0xFee8A195570a18461146F401d6033f5ab3380849",
        97: "0x7b7b1583De1DeB32Ce6605F6deEbF24A0671c17C"
    },
    tradingCompetitionEaster: {
        56: "0xd718baa0B1F4f70dcC8458154042120FFE0DEFFA",
        97: "0xC787F45B833721ED3aC46E99b703B3E1E01abb97"
    },
    tradingCompetitionFanToken: {
        56: "0xA8FECf847e28aa1Df39E995a45b7FCfb91b676d4",
        97: ""
    },
    tradingCompetitionMobox: {
        56: "0x1C5161CdB145dE35a8961F82b065fd1F75C3BaDf",
        97: ""
    },
    tradingCompetitionMoD: {
        56: "0xbDd9a61c67ee16c10f5E37b1D0c907a9EC959f33",
        97: ""
    },
    easterNft: {
        56: "0x23c41D28A239dDCAABd1bb1deF8d057189510066",
        97: "0x24ec6962dbe874F6B67B5C50857565667fA0854F"
    },
    cakeVault: {
        56: "0x45c54210128a065de780C4B0Df3d16664f7f859e",
        97: "0x683433ba14e8F26774D43D3E90DA6Dd7a22044Fe"
    },
    cakeFlexibleSideVault: {
        56: "0x615e896A8C2CA8470A2e9dc2E9552998f8658Ea0",
        97: ""
    },
    predictionsBNB: {
        56: "0x18B2A687610328590Bc8F2e5fEdDe3b582A49cdA",
        97: ""
    },
    predictionsCAKE: {
        56: "0x0E3A8078EDD2021dadcdE733C6b4a86E51EE8f07",
        97: ""
    },
    chainlinkOracleBNB: {
        56: "0xD276fCF34D54A926773c399eBAa772C12ec394aC",
        97: ""
    },
    chainlinkOracleCAKE: {
        56: "0xB6064eD41d4f67e353768aA239cA86f4F73665a1",
        97: ""
    },
    predictionsV1: {
        56: "0x516ffd7d1e0ca40b1879935b2de87cb20fc1124b",
        97: ""
    },
    bunnySpecialCakeVault: {
        56: "0x5B4a770Abe7Eafb2601CA4dF9d73EA99363E60a4",
        97: ""
    },
    bunnySpecialPrediction: {
        56: "0x342c99e9aC24157657095eC69CB04b73257e7A9C",
        97: ""
    },
    bunnySpecialLottery: {
        56: "0x24ED31d31C5868e5a96aA77fdcB890f3511fa0b2",
        97: "0x382cB497110F398F0f152cae82821476AE51c9cF"
    },
    bunnySpecialXmas: {
        56: "0x59EdDF3c21509dA3b0aCCd7c5ccc596d930f4783",
        97: ""
    },
    farmAuction: {
        56: "0xb92Ab7c1edcb273AbA24b0656cEb3681654805D2",
        97: "0x3F9602593b4f7C67ab045DB51BbDEa94E40fA9Fe"
    },
    AnniversaryAchievement: {
        56: "0xF839286bD9D14b358496829F3BaB3145C16ad3C1",
        97: "0x981aE96378e770DE44F89cD9175E708f9EDB70a9"
    },
    nftMarket: {
        56: "0x17539cCa21C7933Df5c980172d22659B8C345C5A",
        97: "0x7f9f37ddcaa33893f9beb3d8748c8d6bfbde6ab2"
    },
    nftSale: {
        56: "0x29fE7148636b7Ae0b1E53777b28dfbaA9327af8E",
        97: "0xe486De509c5381cbdBF3e71F57D7F1f7570f5c46"
    },
    pancakeSquad: {
        56: "0x0a8901b0E25DEb55A87524f0cC164E9644020EBA",
        97: "0xfC0c3F11fDA72Cb9A56F28Ec8D44C0ae4B3ABF86"
    },
    potteryDraw: {
        56: "0x01871991587d5671f3A2d4E2BcDC22F4E026396e",
        97: "0xDB9D365b50E62fce747A90515D2bd1254A16EbB9"
    },
    // TODO: multi
    zap: {
        56: "0xD4c4a7C55c9f7B3c48bafb6E8643Ba79F42418dF",
        97: "0xD85835207054F25620109bdc745EC1D1f84F04e1"
    },
    iCake: {
        56: "0x3C458828D1622F5f4d526eb0d24Da8C4Eb8F07b1",
        97: ""
    },
    bCakeFarmBooster: {
        56: "0xE4FAa3Ef5A9708C894435B0F39c2B440936A3A52",
        97: ""
    },
    bCakeFarmBoosterProxyFactory: {
        56: "0x2C36221bF724c60E9FEE3dd44e2da8017a8EF3BA",
        97: ""
    },
    nonBscVault: {
        56: "0xE6c904424417D03451fADd6E3f5b6c26BcC43841",
        1: "0x2e71B2688019ebdFDdE5A45e6921aaebb15b25fb",
        5: "0xE6c904424417D03451fADd6E3f5b6c26BcC43841"
    },
    crossFarmingSender: {
        56: "0x327d26dE30f92600620A99043034e0A5FD9402C8",
        1: "0x8EA90Ef07f37c77137453C7A1B72B7886d51eCFb",
        5: "0x327d26dE30f92600620A99043034e0A5FD9402C8"
    },
    crossFarmingReceiver: {
        56: "0x0726a8C8206b9eC0AfB788df5adb36a8AEDB13c2",
        97: "0xBab5d3B6bA24E185f216419f3ba07f03984bF983"
    }
});


/***/ }),

/***/ 70627:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$N": () => (/* binding */ getNonBscVaultAddress),
/* harmony export */   "Cf": () => (/* binding */ getPointCenterIfoAddress),
/* harmony export */   "D0": () => (/* binding */ getBCakeFarmBoosterProxyFactoryAddress),
/* harmony export */   "D4": () => (/* binding */ getNftMarketAddress),
/* harmony export */   "Du": () => (/* binding */ getPotteryDrawAddress),
/* harmony export */   "G1": () => (/* binding */ getMasterChefV1Address),
/* harmony export */   "GI": () => (/* binding */ getPancakeBunniesAddress),
/* harmony export */   "I8": () => (/* binding */ getMulticallAddress),
/* harmony export */   "IY": () => (/* binding */ getPancakeSquadAddress),
/* harmony export */   "J0": () => (/* binding */ getTradingCompetitionAddressMoD),
/* harmony export */   "Jc": () => (/* binding */ getAnniversaryAchievement),
/* harmony export */   "Kn": () => (/* binding */ getAddress),
/* harmony export */   "L$": () => (/* binding */ getNftSaleAddress),
/* harmony export */   "O9": () => (/* binding */ getCakeVaultAddress),
/* harmony export */   "Oc": () => (/* binding */ getMasterChefAddress),
/* harmony export */   "Re": () => (/* binding */ getPancakeProfileAddress),
/* harmony export */   "S4": () => (/* binding */ getBunnyFactoryAddress),
/* harmony export */   "X8": () => (/* binding */ getTradingCompetitionAddressMobox),
/* harmony export */   "XH": () => (/* binding */ getBCakeFarmBoosterAddress),
/* harmony export */   "ZX": () => (/* binding */ getVaultPoolAddress),
/* harmony export */   "_M": () => (/* binding */ getZapAddress),
/* harmony export */   "cH": () => (/* binding */ getCrossFarmingSenderAddress),
/* harmony export */   "ck": () => (/* binding */ getICakeAddress),
/* harmony export */   "kN": () => (/* binding */ getLotteryV2Address),
/* harmony export */   "pO": () => (/* binding */ getCakeFlexibleSideVaultAddress),
/* harmony export */   "rY": () => (/* binding */ getTradingCompetitionAddressEaster),
/* harmony export */   "rz": () => (/* binding */ getFarmAuctionAddress),
/* harmony export */   "t_": () => (/* binding */ getTradingCompetitionAddressFanToken),
/* harmony export */   "uK": () => (/* binding */ getCrossFarmingReceiverAddress),
/* harmony export */   "wA": () => (/* binding */ getPredictionsV1Address)
/* harmony export */ });
/* unused harmony exports getClaimRefundAddress, getBunnySpecialAddress, getEasterNftAddress, getBunnySpecialCakeVaultAddress, getBunnySpecialPredictionAddress, getBunnySpecialLotteryAddress, getBunnySpecialXmasAddress */
/* harmony import */ var _pancakeswap_sdk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(43086);
/* harmony import */ var _pancakeswap_sdk__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_pancakeswap_sdk__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var config_constants_contracts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(51642);


const getAddress = (address, chainId)=>{
    return address[chainId] ? address[chainId] : address[_pancakeswap_sdk__WEBPACK_IMPORTED_MODULE_0__.ChainId.BSC];
};
const getMasterChefAddress = (chainId)=>{
    return getAddress(config_constants_contracts__WEBPACK_IMPORTED_MODULE_1__/* ["default"].masterChef */ .Z.masterChef, chainId);
};
const getMasterChefV1Address = ()=>{
    return getAddress(config_constants_contracts__WEBPACK_IMPORTED_MODULE_1__/* ["default"].masterChefV1 */ .Z.masterChefV1);
};
const getMulticallAddress = (chainId)=>{
    return getAddress(config_constants_contracts__WEBPACK_IMPORTED_MODULE_1__/* ["default"].multiCall */ .Z.multiCall, chainId);
};
const getLotteryV2Address = ()=>{
    return getAddress(config_constants_contracts__WEBPACK_IMPORTED_MODULE_1__/* ["default"].lotteryV2 */ .Z.lotteryV2);
};
const getPancakeProfileAddress = ()=>{
    return getAddress(config_constants_contracts__WEBPACK_IMPORTED_MODULE_1__/* ["default"].pancakeProfile */ .Z.pancakeProfile);
};
const getPancakeBunniesAddress = ()=>{
    return getAddress(config_constants_contracts__WEBPACK_IMPORTED_MODULE_1__/* ["default"].pancakeBunnies */ .Z.pancakeBunnies);
};
const getBunnyFactoryAddress = ()=>{
    return getAddress(config_constants_contracts__WEBPACK_IMPORTED_MODULE_1__/* ["default"].bunnyFactory */ .Z.bunnyFactory);
};
const getPredictionsV1Address = ()=>{
    return getAddress(config_constants_contracts__WEBPACK_IMPORTED_MODULE_1__/* ["default"].predictionsV1 */ .Z.predictionsV1);
};
const getClaimRefundAddress = ()=>{
    return getAddress(addresses.claimRefund);
};
const getPointCenterIfoAddress = ()=>{
    return getAddress(config_constants_contracts__WEBPACK_IMPORTED_MODULE_1__/* ["default"].pointCenterIfo */ .Z.pointCenterIfo);
};
const getBunnySpecialAddress = ()=>{
    return getAddress(addresses.bunnySpecial);
};
const getTradingCompetitionAddressEaster = ()=>{
    return getAddress(config_constants_contracts__WEBPACK_IMPORTED_MODULE_1__/* ["default"].tradingCompetitionEaster */ .Z.tradingCompetitionEaster);
};
const getTradingCompetitionAddressFanToken = ()=>{
    return getAddress(config_constants_contracts__WEBPACK_IMPORTED_MODULE_1__/* ["default"].tradingCompetitionFanToken */ .Z.tradingCompetitionFanToken);
};
const getTradingCompetitionAddressMobox = ()=>{
    return getAddress(config_constants_contracts__WEBPACK_IMPORTED_MODULE_1__/* ["default"].tradingCompetitionMobox */ .Z.tradingCompetitionMobox);
};
const getTradingCompetitionAddressMoD = ()=>{
    return getAddress(config_constants_contracts__WEBPACK_IMPORTED_MODULE_1__/* ["default"].tradingCompetitionMoD */ .Z.tradingCompetitionMoD);
};
const getEasterNftAddress = ()=>{
    return getAddress(addresses.easterNft);
};
const getVaultPoolAddress = (vaultKey)=>{
    if (!vaultKey) {
        return null;
    }
    return getAddress(config_constants_contracts__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z[vaultKey]);
};
const getCakeVaultAddress = ()=>{
    return getAddress(config_constants_contracts__WEBPACK_IMPORTED_MODULE_1__/* ["default"].cakeVault */ .Z.cakeVault);
};
const getCakeFlexibleSideVaultAddress = ()=>{
    return getAddress(config_constants_contracts__WEBPACK_IMPORTED_MODULE_1__/* ["default"].cakeFlexibleSideVault */ .Z.cakeFlexibleSideVault);
};
const getBunnySpecialCakeVaultAddress = ()=>{
    return getAddress(addresses.bunnySpecialCakeVault);
};
const getBunnySpecialPredictionAddress = ()=>{
    return getAddress(addresses.bunnySpecialPrediction);
};
const getBunnySpecialLotteryAddress = ()=>{
    return getAddress(addresses.bunnySpecialLottery);
};
const getBunnySpecialXmasAddress = ()=>{
    return getAddress(addresses.bunnySpecialXmas);
};
const getFarmAuctionAddress = ()=>{
    return getAddress(config_constants_contracts__WEBPACK_IMPORTED_MODULE_1__/* ["default"].farmAuction */ .Z.farmAuction);
};
const getAnniversaryAchievement = ()=>{
    return getAddress(config_constants_contracts__WEBPACK_IMPORTED_MODULE_1__/* ["default"].AnniversaryAchievement */ .Z.AnniversaryAchievement);
};
const getNftMarketAddress = ()=>{
    return getAddress(config_constants_contracts__WEBPACK_IMPORTED_MODULE_1__/* ["default"].nftMarket */ .Z.nftMarket);
};
const getNftSaleAddress = ()=>{
    return getAddress(config_constants_contracts__WEBPACK_IMPORTED_MODULE_1__/* ["default"].nftSale */ .Z.nftSale);
};
const getPancakeSquadAddress = ()=>{
    return getAddress(config_constants_contracts__WEBPACK_IMPORTED_MODULE_1__/* ["default"].pancakeSquad */ .Z.pancakeSquad);
};
const getPotteryDrawAddress = ()=>{
    return getAddress(config_constants_contracts__WEBPACK_IMPORTED_MODULE_1__/* ["default"].potteryDraw */ .Z.potteryDraw);
};
const getZapAddress = ()=>{
    return getAddress(config_constants_contracts__WEBPACK_IMPORTED_MODULE_1__/* ["default"].zap */ .Z.zap);
};
const getICakeAddress = ()=>{
    return getAddress(config_constants_contracts__WEBPACK_IMPORTED_MODULE_1__/* ["default"].iCake */ .Z.iCake);
};
const getBCakeFarmBoosterAddress = ()=>{
    return getAddress(config_constants_contracts__WEBPACK_IMPORTED_MODULE_1__/* ["default"].bCakeFarmBooster */ .Z.bCakeFarmBooster);
};
const getBCakeFarmBoosterProxyFactoryAddress = ()=>{
    return getAddress(config_constants_contracts__WEBPACK_IMPORTED_MODULE_1__/* ["default"].bCakeFarmBoosterProxyFactory */ .Z.bCakeFarmBoosterProxyFactory);
};
const getNonBscVaultAddress = (chainId)=>{
    return getAddress(config_constants_contracts__WEBPACK_IMPORTED_MODULE_1__/* ["default"].nonBscVault */ .Z.nonBscVault, chainId);
};
const getCrossFarmingSenderAddress = (chainId)=>{
    return getAddress(config_constants_contracts__WEBPACK_IMPORTED_MODULE_1__/* ["default"].crossFarmingSender */ .Z.crossFarmingSender, chainId);
};
const getCrossFarmingReceiverAddress = (chainId)=>{
    return getAddress(config_constants_contracts__WEBPACK_IMPORTED_MODULE_1__/* ["default"].crossFarmingReceiver */ .Z.crossFarmingReceiver, chainId);
};


/***/ }),

/***/ 82547:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "wn": () => (/* binding */ createMulticall),
  "dl": () => (/* binding */ multicallAddresses)
});

// UNUSED EXPORTS: getMulticallContract

// EXTERNAL MODULE: external "@ethersproject/abi"
var abi_ = __webpack_require__(6187);
// EXTERNAL MODULE: external "@ethersproject/contracts"
var contracts_ = __webpack_require__(12792);
// EXTERNAL MODULE: ../../packages/swap-sdk/dist/index.js
var dist = __webpack_require__(43086);
;// CONCATENATED MODULE: ../../packages/multicall/Multicall.json
const Multicall_namespaceObject = JSON.parse('[{"inputs":[{"components":[{"internalType":"address","name":"target","type":"address"},{"internalType":"bytes","name":"callData","type":"bytes"}],"internalType":"struct Multicall3.Call[]","name":"calls","type":"tuple[]"}],"name":"aggregate","outputs":[{"internalType":"uint256","name":"blockNumber","type":"uint256"},{"internalType":"bytes[]","name":"returnData","type":"bytes[]"}],"stateMutability":"payable","type":"function"},{"inputs":[{"components":[{"internalType":"address","name":"target","type":"address"},{"internalType":"bool","name":"allowFailure","type":"bool"},{"internalType":"bytes","name":"callData","type":"bytes"}],"internalType":"struct Multicall3.Call3[]","name":"calls","type":"tuple[]"}],"name":"aggregate3","outputs":[{"components":[{"internalType":"bool","name":"success","type":"bool"},{"internalType":"bytes","name":"returnData","type":"bytes"}],"internalType":"struct Multicall3.Result[]","name":"returnData","type":"tuple[]"}],"stateMutability":"payable","type":"function"},{"inputs":[{"components":[{"internalType":"address","name":"target","type":"address"},{"internalType":"bool","name":"allowFailure","type":"bool"},{"internalType":"uint256","name":"value","type":"uint256"},{"internalType":"bytes","name":"callData","type":"bytes"}],"internalType":"struct Multicall3.Call3Value[]","name":"calls","type":"tuple[]"}],"name":"aggregate3Value","outputs":[{"components":[{"internalType":"bool","name":"success","type":"bool"},{"internalType":"bytes","name":"returnData","type":"bytes"}],"internalType":"struct Multicall3.Result[]","name":"returnData","type":"tuple[]"}],"stateMutability":"payable","type":"function"},{"inputs":[{"components":[{"internalType":"address","name":"target","type":"address"},{"internalType":"bytes","name":"callData","type":"bytes"}],"internalType":"struct Multicall3.Call[]","name":"calls","type":"tuple[]"}],"name":"blockAndAggregate","outputs":[{"internalType":"uint256","name":"blockNumber","type":"uint256"},{"internalType":"bytes32","name":"blockHash","type":"bytes32"},{"components":[{"internalType":"bool","name":"success","type":"bool"},{"internalType":"bytes","name":"returnData","type":"bytes"}],"internalType":"struct Multicall3.Result[]","name":"returnData","type":"tuple[]"}],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"getBasefee","outputs":[{"internalType":"uint256","name":"basefee","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"blockNumber","type":"uint256"}],"name":"getBlockHash","outputs":[{"internalType":"bytes32","name":"blockHash","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getBlockNumber","outputs":[{"internalType":"uint256","name":"blockNumber","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getChainId","outputs":[{"internalType":"uint256","name":"chainid","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getCurrentBlockCoinbase","outputs":[{"internalType":"address","name":"coinbase","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getCurrentBlockDifficulty","outputs":[{"internalType":"uint256","name":"difficulty","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getCurrentBlockGasLimit","outputs":[{"internalType":"uint256","name":"gaslimit","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getCurrentBlockTimestamp","outputs":[{"internalType":"uint256","name":"timestamp","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"addr","type":"address"}],"name":"getEthBalance","outputs":[{"internalType":"uint256","name":"balance","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getLastBlockHash","outputs":[{"internalType":"bytes32","name":"blockHash","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bool","name":"requireSuccess","type":"bool"},{"components":[{"internalType":"address","name":"target","type":"address"},{"internalType":"bytes","name":"callData","type":"bytes"}],"internalType":"struct Multicall3.Call[]","name":"calls","type":"tuple[]"}],"name":"tryAggregate","outputs":[{"components":[{"internalType":"bool","name":"success","type":"bool"},{"internalType":"bytes","name":"returnData","type":"bytes"}],"internalType":"struct Multicall3.Result[]","name":"returnData","type":"tuple[]"}],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"bool","name":"requireSuccess","type":"bool"},{"components":[{"internalType":"address","name":"target","type":"address"},{"internalType":"bytes","name":"callData","type":"bytes"}],"internalType":"struct Multicall3.Call[]","name":"calls","type":"tuple[]"}],"name":"tryBlockAndAggregate","outputs":[{"internalType":"uint256","name":"blockNumber","type":"uint256"},{"internalType":"bytes32","name":"blockHash","type":"bytes32"},{"components":[{"internalType":"bool","name":"success","type":"bool"},{"internalType":"bytes","name":"returnData","type":"bytes"}],"internalType":"struct Multicall3.Result[]","name":"returnData","type":"tuple[]"}],"stateMutability":"payable","type":"function"}]');
;// CONCATENATED MODULE: ../../packages/multicall/index.ts




const multicallAddresses = {
    1: "0xcA11bde05977b3631167028862bE2a173976CA11",
    4: "0xcA11bde05977b3631167028862bE2a173976CA11",
    5: "0xcA11bde05977b3631167028862bE2a173976CA11",
    56: "0xcA11bde05977b3631167028862bE2a173976CA11",
    97: "0xcA11bde05977b3631167028862bE2a173976CA11"
};
const getMulticallContract = (chainId, provider)=>{
    if (multicallAddresses[chainId]) {
        return new contracts_.Contract(multicallAddresses[chainId], Multicall_namespaceObject, provider);
    }
    return null;
};
function createMulticall(provider) {
    const multicall = async (abi, calls, chainId = dist.ChainId.BSC)=>{
        const multi = getMulticallContract(chainId, provider({
            chainId
        }));
        if (!multi) throw new Error(`Multicall Provider missing for ${chainId}`);
        const itf = new abi_.Interface(abi);
        const calldata = calls.map((call)=>({
                target: call.address.toLowerCase(),
                callData: itf.encodeFunctionData(call.name, call.params)
            }));
        const { returnData  } = await multi.callStatic.aggregate(calldata);
        const res = returnData.map((call, i)=>itf.decodeFunctionResult(calls[i].name, call));
        return res;
    };
    const multicallv2 = async ({ abi , calls , chainId =dist.ChainId.BSC , options , provider: _provider  })=>{
        const { requireSuccess =true , ...overrides } = options || {};
        const multi = getMulticallContract(chainId, _provider || provider({
            chainId
        }));
        if (!multi) throw new Error(`Multicall Provider missing for ${chainId}`);
        const itf = new abi_.Interface(abi);
        const calldata = calls.map((call)=>({
                target: call.address.toLowerCase(),
                callData: itf.encodeFunctionData(call.name, call.params)
            }));
        const returnData = await multi.callStatic.tryAggregate(requireSuccess, calldata, overrides);
        const res = returnData.map((call, i)=>{
            const [result, data] = call;
            return result ? itf.decodeFunctionResult(calls[i].name, data) : null;
        });
        return res;
    };
    const multicallv3 = async ({ calls , chainId =dist.ChainId.BSC , allowFailure , overrides  })=>{
        const multi = getMulticallContract(chainId, provider({
            chainId
        }));
        if (!multi) throw new Error(`Multicall Provider missing for ${chainId}`);
        const _calls = calls.map(({ abi , address , name , params , allowFailure: _allowFailure  })=>{
            const contract = new contracts_.Contract(address, abi);
            const callData = contract.interface.encodeFunctionData(name, params ?? []);
            if (!contract[name]) console.error(`${name} missing on ${address}`);
            return {
                target: address,
                allowFailure: allowFailure || _allowFailure,
                callData
            };
        });
        const result = await multi.callStatic.aggregate3([
            ...[
                _calls
            ],
            ...overrides ? [
                overrides
            ] : []
        ]);
        return result.map((call, i)=>{
            const { returnData , success  } = call;
            if (!success || returnData === "0x") return null;
            const { address , abi , name  } = calls[i];
            const contract = new contracts_.Contract(address, abi);
            const decoded = contract.interface.decodeFunctionResult(name, returnData);
            return decoded;
        });
    };
    return {
        multicall,
        multicallv2,
        multicallv3
    };
}


/***/ }),

/***/ 46539:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
        value: mod,
        enumerable: true
    }) : target, mod));
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
// src/index.ts
var src_exports = {};
__export(src_exports, {
    BaseCurrency: ()=>BaseCurrency,
    CurrencyAmount: ()=>CurrencyAmount,
    FIVE: ()=>FIVE,
    Fraction: ()=>Fraction,
    InsufficientInputAmountError: ()=>InsufficientInputAmountError,
    InsufficientReservesError: ()=>InsufficientReservesError,
    JSBI: ()=>import_jsbi7.default,
    MINIMUM_LIQUIDITY: ()=>MINIMUM_LIQUIDITY,
    MaxUint256: ()=>MaxUint256,
    NativeCurrency: ()=>NativeCurrency,
    ONE: ()=>ONE,
    Percent: ()=>Percent,
    Price: ()=>Price,
    Rounding: ()=>Rounding,
    TEN: ()=>TEN,
    THREE: ()=>THREE,
    TWO: ()=>TWO,
    Token: ()=>Token,
    TradeType: ()=>TradeType,
    VMType: ()=>VMType,
    VM_TYPE_MAXIMA: ()=>VM_TYPE_MAXIMA,
    ZERO: ()=>ZERO,
    _100: ()=>_100,
    _10000: ()=>_10000,
    _9975: ()=>_9975,
    computePriceImpact: ()=>computePriceImpact,
    sortedInsert: ()=>sortedInsert,
    sqrt: ()=>sqrt,
    validateVMTypeInstance: ()=>validateVMTypeInstance
});
module.exports = __toCommonJS(src_exports);
var import_jsbi7 = __toESM(__webpack_require__(52424));
// src/constants.ts
var import_jsbi = __toESM(__webpack_require__(52424));
var TradeType = /* @__PURE__ */ ((TradeType2)=>{
    TradeType2[TradeType2["EXACT_INPUT"] = 0] = "EXACT_INPUT";
    TradeType2[TradeType2["EXACT_OUTPUT"] = 1] = "EXACT_OUTPUT";
    return TradeType2;
})(TradeType || {});
var Rounding = /* @__PURE__ */ ((Rounding2)=>{
    Rounding2[Rounding2["ROUND_DOWN"] = 0] = "ROUND_DOWN";
    Rounding2[Rounding2["ROUND_HALF_UP"] = 1] = "ROUND_HALF_UP";
    Rounding2[Rounding2["ROUND_UP"] = 2] = "ROUND_UP";
    return Rounding2;
})(Rounding || {});
var MINIMUM_LIQUIDITY = import_jsbi.default.BigInt(1e3);
var ZERO = import_jsbi.default.BigInt(0);
var ONE = import_jsbi.default.BigInt(1);
var TWO = import_jsbi.default.BigInt(2);
var THREE = import_jsbi.default.BigInt(3);
var FIVE = import_jsbi.default.BigInt(5);
var TEN = import_jsbi.default.BigInt(10);
var _100 = import_jsbi.default.BigInt(100);
var _9975 = import_jsbi.default.BigInt(9975);
var _10000 = import_jsbi.default.BigInt(1e4);
var MaxUint256 = import_jsbi.default.BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var VMType = /* @__PURE__ */ ((VMType2)=>{
    VMType2["uint8"] = "uint8";
    VMType2["uint256"] = "uint256";
    return VMType2;
})(VMType || {});
var VM_TYPE_MAXIMA = {
    ["uint8" /* uint8 */ ]: import_jsbi.default.BigInt("0xff"),
    ["uint256" /* uint256 */ ]: import_jsbi.default.BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff")
};
// src/baseCurrency.ts
var import_tiny_invariant = __toESM(__webpack_require__(8780));
var BaseCurrency = class {
    constructor(chainId, decimals, symbol, name){
        (0, import_tiny_invariant.default)(Number.isSafeInteger(chainId), "CHAIN_ID");
        (0, import_tiny_invariant.default)(decimals >= 0 && decimals < 255 && Number.isInteger(decimals), "DECIMALS");
        this.chainId = chainId;
        this.decimals = decimals;
        this.symbol = symbol;
        this.name = name;
    }
};
// src/fractions/fraction.ts
var import_jsbi2 = __toESM(__webpack_require__(52424));
var import_tiny_invariant2 = __toESM(__webpack_require__(8780));
var import_decimal = __toESM(__webpack_require__(97312));
var import_big = __toESM(__webpack_require__(22575));
var import_toformat = __toESM(__webpack_require__(86350));
var Decimal = (0, import_toformat.default)(import_decimal.default);
var Big = (0, import_toformat.default)(import_big.default);
var toSignificantRounding = {
    [0 /* ROUND_DOWN */ ]: Decimal.ROUND_DOWN,
    [1 /* ROUND_HALF_UP */ ]: Decimal.ROUND_HALF_UP,
    [2 /* ROUND_UP */ ]: Decimal.ROUND_UP
};
var toFixedRounding = {
    [0 /* ROUND_DOWN */ ]: 0 /* RoundDown */ ,
    [1 /* ROUND_HALF_UP */ ]: 1 /* RoundHalfUp */ ,
    [2 /* ROUND_UP */ ]: 3 /* RoundUp */ 
};
var Fraction = class {
    constructor(numerator, denominator = import_jsbi2.default.BigInt(1)){
        this.numerator = import_jsbi2.default.BigInt(numerator);
        this.denominator = import_jsbi2.default.BigInt(denominator);
    }
    static tryParseFraction(fractionish) {
        if (fractionish instanceof import_jsbi2.default || typeof fractionish === "number" || typeof fractionish === "string") return new Fraction(fractionish);
        if ("numerator" in fractionish && "denominator" in fractionish) return fractionish;
        throw new Error("Could not parse fraction");
    }
    get quotient() {
        return import_jsbi2.default.divide(this.numerator, this.denominator);
    }
    get remainder() {
        return new Fraction(import_jsbi2.default.remainder(this.numerator, this.denominator), this.denominator);
    }
    invert() {
        return new Fraction(this.denominator, this.numerator);
    }
    add(other) {
        const otherParsed = Fraction.tryParseFraction(other);
        if (import_jsbi2.default.equal(this.denominator, otherParsed.denominator)) {
            return new Fraction(import_jsbi2.default.add(this.numerator, otherParsed.numerator), this.denominator);
        }
        return new Fraction(import_jsbi2.default.add(import_jsbi2.default.multiply(this.numerator, otherParsed.denominator), import_jsbi2.default.multiply(otherParsed.numerator, this.denominator)), import_jsbi2.default.multiply(this.denominator, otherParsed.denominator));
    }
    subtract(other) {
        const otherParsed = Fraction.tryParseFraction(other);
        if (import_jsbi2.default.equal(this.denominator, otherParsed.denominator)) {
            return new Fraction(import_jsbi2.default.subtract(this.numerator, otherParsed.numerator), this.denominator);
        }
        return new Fraction(import_jsbi2.default.subtract(import_jsbi2.default.multiply(this.numerator, otherParsed.denominator), import_jsbi2.default.multiply(otherParsed.numerator, this.denominator)), import_jsbi2.default.multiply(this.denominator, otherParsed.denominator));
    }
    lessThan(other) {
        const otherParsed = Fraction.tryParseFraction(other);
        return import_jsbi2.default.lessThan(import_jsbi2.default.multiply(this.numerator, otherParsed.denominator), import_jsbi2.default.multiply(otherParsed.numerator, this.denominator));
    }
    equalTo(other) {
        const otherParsed = Fraction.tryParseFraction(other);
        return import_jsbi2.default.equal(import_jsbi2.default.multiply(this.numerator, otherParsed.denominator), import_jsbi2.default.multiply(otherParsed.numerator, this.denominator));
    }
    greaterThan(other) {
        const otherParsed = Fraction.tryParseFraction(other);
        return import_jsbi2.default.greaterThan(import_jsbi2.default.multiply(this.numerator, otherParsed.denominator), import_jsbi2.default.multiply(otherParsed.numerator, this.denominator));
    }
    multiply(other) {
        const otherParsed = Fraction.tryParseFraction(other);
        return new Fraction(import_jsbi2.default.multiply(this.numerator, otherParsed.numerator), import_jsbi2.default.multiply(this.denominator, otherParsed.denominator));
    }
    divide(other) {
        const otherParsed = Fraction.tryParseFraction(other);
        return new Fraction(import_jsbi2.default.multiply(this.numerator, otherParsed.denominator), import_jsbi2.default.multiply(this.denominator, otherParsed.numerator));
    }
    toSignificant(significantDigits, format = {
        groupSeparator: ""
    }, rounding = 1 /* ROUND_HALF_UP */ ) {
        (0, import_tiny_invariant2.default)(Number.isInteger(significantDigits), `${significantDigits} is not an integer.`);
        (0, import_tiny_invariant2.default)(significantDigits > 0, `${significantDigits} is not positive.`);
        Decimal.set({
            precision: significantDigits + 1,
            rounding: toSignificantRounding[rounding]
        });
        const quotient = new Decimal(this.numerator.toString()).div(this.denominator.toString()).toSignificantDigits(significantDigits);
        return quotient.toFormat(quotient.decimalPlaces(), format);
    }
    toFixed(decimalPlaces, format = {
        groupSeparator: ""
    }, rounding = 1 /* ROUND_HALF_UP */ ) {
        (0, import_tiny_invariant2.default)(Number.isInteger(decimalPlaces), `${decimalPlaces} is not an integer.`);
        (0, import_tiny_invariant2.default)(decimalPlaces >= 0, `${decimalPlaces} is negative.`);
        Big.DP = decimalPlaces;
        Big.RM = toFixedRounding[rounding];
        return new Big(this.numerator.toString()).div(this.denominator.toString()).toFormat(decimalPlaces, format);
    }
    get asFraction() {
        return new Fraction(this.numerator, this.denominator);
    }
};
// src/fractions/percent.ts
var import_jsbi3 = __toESM(__webpack_require__(52424));
var ONE_HUNDRED = new Fraction(import_jsbi3.default.BigInt(100));
function toPercent(fraction) {
    return new Percent(fraction.numerator, fraction.denominator);
}
var Percent = class extends Fraction {
    constructor(){
        super(...arguments);
        this.isPercent = true;
    }
    add(other) {
        return toPercent(super.add(other));
    }
    subtract(other) {
        return toPercent(super.subtract(other));
    }
    multiply(other) {
        return toPercent(super.multiply(other));
    }
    divide(other) {
        return toPercent(super.divide(other));
    }
    toSignificant(significantDigits = 5, format, rounding) {
        return super.multiply(ONE_HUNDRED).toSignificant(significantDigits, format, rounding);
    }
    toFixed(decimalPlaces = 2, format, rounding) {
        return super.multiply(ONE_HUNDRED).toFixed(decimalPlaces, format, rounding);
    }
};
// src/fractions/currencyAmount.ts
var import_tiny_invariant3 = __toESM(__webpack_require__(8780));
var import_jsbi4 = __toESM(__webpack_require__(52424));
var import_big2 = __toESM(__webpack_require__(22575));
var import_toformat2 = __toESM(__webpack_require__(86350));
var Big2 = (0, import_toformat2.default)(import_big2.default);
var CurrencyAmount = class extends Fraction {
    constructor(currency, numerator, denominator){
        super(numerator, denominator);
        (0, import_tiny_invariant3.default)(import_jsbi4.default.lessThanOrEqual(this.quotient, MaxUint256), "AMOUNT");
        this.currency = currency;
        this.decimalScale = import_jsbi4.default.exponentiate(import_jsbi4.default.BigInt(10), import_jsbi4.default.BigInt(currency.decimals));
    }
    static fromRawAmount(currency, rawAmount) {
        return new CurrencyAmount(currency, rawAmount);
    }
    static fromFractionalAmount(currency, numerator, denominator) {
        return new CurrencyAmount(currency, numerator, denominator);
    }
    add(other) {
        (0, import_tiny_invariant3.default)(this.currency.equals(other.currency), "CURRENCY");
        const added = super.add(other);
        return CurrencyAmount.fromFractionalAmount(this.currency, added.numerator, added.denominator);
    }
    subtract(other) {
        (0, import_tiny_invariant3.default)(this.currency.equals(other.currency), "CURRENCY");
        const subtracted = super.subtract(other);
        return CurrencyAmount.fromFractionalAmount(this.currency, subtracted.numerator, subtracted.denominator);
    }
    multiply(other) {
        const multiplied = super.multiply(other);
        return CurrencyAmount.fromFractionalAmount(this.currency, multiplied.numerator, multiplied.denominator);
    }
    divide(other) {
        const divided = super.divide(other);
        return CurrencyAmount.fromFractionalAmount(this.currency, divided.numerator, divided.denominator);
    }
    toSignificant(significantDigits = 6, format, rounding = 0 /* ROUND_DOWN */ ) {
        return super.divide(this.decimalScale).toSignificant(significantDigits, format, rounding);
    }
    toFixed(decimalPlaces = this.currency.decimals, format, rounding = 0 /* ROUND_DOWN */ ) {
        (0, import_tiny_invariant3.default)(decimalPlaces <= this.currency.decimals, "DECIMALS");
        return super.divide(this.decimalScale).toFixed(decimalPlaces, format, rounding);
    }
    toExact(format = {
        groupSeparator: ""
    }) {
        Big2.DP = this.currency.decimals;
        return new Big2(this.quotient.toString()).div(this.decimalScale.toString()).toFormat(format);
    }
    get wrapped() {
        if (this.currency.isToken) return this;
        return CurrencyAmount.fromFractionalAmount(this.currency.wrapped, this.numerator, this.denominator);
    }
};
// src/fractions/price.ts
var import_jsbi5 = __toESM(__webpack_require__(52424));
var import_tiny_invariant4 = __toESM(__webpack_require__(8780));
var Price = class extends Fraction {
    constructor(...args){
        let baseCurrency;
        let quoteCurrency;
        let denominator;
        let numerator;
        if (args.length === 4) {
            ;
            [baseCurrency, quoteCurrency, denominator, numerator] = args;
        } else {
            const result = args[0].quoteAmount.divide(args[0].baseAmount);
            [baseCurrency, quoteCurrency, denominator, numerator] = [
                args[0].baseAmount.currency,
                args[0].quoteAmount.currency,
                result.denominator,
                result.numerator
            ];
        }
        super(numerator, denominator);
        this.baseCurrency = baseCurrency;
        this.quoteCurrency = quoteCurrency;
        this.scalar = new Fraction(import_jsbi5.default.exponentiate(import_jsbi5.default.BigInt(10), import_jsbi5.default.BigInt(baseCurrency.decimals)), import_jsbi5.default.exponentiate(import_jsbi5.default.BigInt(10), import_jsbi5.default.BigInt(quoteCurrency.decimals)));
    }
    invert() {
        return new Price(this.quoteCurrency, this.baseCurrency, this.numerator, this.denominator);
    }
    multiply(other) {
        (0, import_tiny_invariant4.default)(this.quoteCurrency.equals(other.baseCurrency), "TOKEN");
        const fraction = super.multiply(other);
        return new Price(this.baseCurrency, other.quoteCurrency, fraction.denominator, fraction.numerator);
    }
    quote(currencyAmount) {
        (0, import_tiny_invariant4.default)(currencyAmount.currency.equals(this.baseCurrency), "TOKEN");
        const result = super.multiply(currencyAmount);
        return CurrencyAmount.fromFractionalAmount(this.quoteCurrency, result.numerator, result.denominator);
    }
    get adjustedForDecimals() {
        return super.multiply(this.scalar);
    }
    toSignificant(significantDigits = 6, format, rounding) {
        return this.adjustedForDecimals.toSignificant(significantDigits, format, rounding);
    }
    toFixed(decimalPlaces = 4, format, rounding) {
        return this.adjustedForDecimals.toFixed(decimalPlaces, format, rounding);
    }
};
// src/nativeCurrency.ts
var NativeCurrency = class extends BaseCurrency {
    constructor(){
        super(...arguments);
        this.isNative = true;
        this.isToken = false;
    }
};
// src/token.ts
var import_tiny_invariant5 = __toESM(__webpack_require__(8780));
var Token = class extends BaseCurrency {
    constructor(chainId, address, decimals, symbol, name, projectLink){
        super(chainId, decimals, symbol, name);
        this.isNative = false;
        this.isToken = true;
        this.address = address;
        this.projectLink = projectLink;
    }
    equals(other) {
        return other.isToken && this.chainId === other.chainId && this.address === other.address;
    }
    sortsBefore(other) {
        (0, import_tiny_invariant5.default)(this.chainId === other.chainId, "CHAIN_IDS");
        (0, import_tiny_invariant5.default)(this.address !== other.address, "ADDRESSES");
        return this.address.toLowerCase() < other.address.toLowerCase();
    }
    get wrapped() {
        return this;
    }
    get serialize() {
        return {
            address: this.address,
            chainId: this.chainId,
            decimals: this.decimals,
            symbol: this.symbol,
            name: this.name,
            projectLink: this.projectLink
        };
    }
};
// src/errors.ts
var CAN_SET_PROTOTYPE = "setPrototypeOf" in Object;
var InsufficientReservesError = class extends Error {
    constructor(){
        super();
        this.isInsufficientReservesError = true;
        this.name = this.constructor.name;
        if (CAN_SET_PROTOTYPE) Object.setPrototypeOf(this, new.target.prototype);
    }
};
var InsufficientInputAmountError = class extends Error {
    constructor(){
        super();
        this.isInsufficientInputAmountError = true;
        this.name = this.constructor.name;
        if (CAN_SET_PROTOTYPE) Object.setPrototypeOf(this, new.target.prototype);
    }
};
// src/utils.ts
var import_jsbi6 = __toESM(__webpack_require__(52424));
var import_tiny_invariant6 = __toESM(__webpack_require__(8780));
function validateVMTypeInstance(value, vmType) {
    (0, import_tiny_invariant6.default)(import_jsbi6.default.greaterThanOrEqual(value, ZERO), `${value} is not a ${vmType}.`);
    (0, import_tiny_invariant6.default)(import_jsbi6.default.lessThanOrEqual(value, VM_TYPE_MAXIMA[vmType]), `${value} is not a ${vmType}.`);
}
function sqrt(y) {
    validateVMTypeInstance(y, "uint256" /* uint256 */ );
    let z = ZERO;
    let x;
    if (import_jsbi6.default.greaterThan(y, THREE)) {
        z = y;
        x = import_jsbi6.default.add(import_jsbi6.default.divide(y, TWO), ONE);
        while(import_jsbi6.default.lessThan(x, z)){
            z = x;
            x = import_jsbi6.default.divide(import_jsbi6.default.add(import_jsbi6.default.divide(y, x), x), TWO);
        }
    } else if (import_jsbi6.default.notEqual(y, ZERO)) {
        z = ONE;
    }
    return z;
}
function sortedInsert(items, add, maxSize, comparator) {
    (0, import_tiny_invariant6.default)(maxSize > 0, "MAX_SIZE_ZERO");
    (0, import_tiny_invariant6.default)(items.length <= maxSize, "ITEMS_SIZE");
    if (items.length === 0) {
        items.push(add);
        return null;
    } else {
        const isFull = items.length === maxSize;
        if (isFull && comparator(items[items.length - 1], add) <= 0) {
            return add;
        }
        let lo = 0, hi = items.length;
        while(lo < hi){
            const mid = lo + hi >>> 1;
            if (comparator(items[mid], add) <= 0) {
                lo = mid + 1;
            } else {
                hi = mid;
            }
        }
        items.splice(lo, 0, add);
        return isFull ? items.pop() : null;
    }
}
function computePriceImpact(midPrice, inputAmount, outputAmount) {
    const quotedOutputAmount = midPrice.quote(inputAmount);
    const priceImpact = quotedOutputAmount.subtract(outputAmount).divide(quotedOutputAmount);
    return new Percent(priceImpact.numerator, priceImpact.denominator);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (0);


/***/ }),

/***/ 43086:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  ChainId: () => ChainId,
  ERC20Token: () => ERC20Token,
  FACTORY_ADDRESS: () => FACTORY_ADDRESS,
  FACTORY_ADDRESS_MAP: () => FACTORY_ADDRESS_MAP,
  INIT_CODE_HASH: () => INIT_CODE_HASH,
  INIT_CODE_HASH_MAP: () => INIT_CODE_HASH_MAP,
  JSBI: () => import_jsbi3.default,
  NATIVE: () => NATIVE,
  Native: () => Native,
  Pair: () => Pair,
  Route: () => Route,
  Router: () => Router,
  Trade: () => Trade,
  WBNB: () => WBNB,
  WETH9: () => WETH9,
  WNATIVE: () => WNATIVE,
  computePairAddress: () => computePairAddress,
  computePriceImpact: () => computePriceImpact,
  inputOutputComparator: () => inputOutputComparator,
  tradeComparator: () => tradeComparator
});
module.exports = __toCommonJS(src_exports);
var import_jsbi3 = __toESM(__webpack_require__(52424));

// src/entities/token.ts
var import_swap_sdk_core2 = __webpack_require__(46539);

// src/utils.ts
var import_address = __webpack_require__(51541);
var import_jsbi = __toESM(__webpack_require__(52424));
var import_tiny_invariant = __toESM(__webpack_require__(8780));
var import_tiny_warning = __toESM(__webpack_require__(60656));
var import_swap_sdk_core = __webpack_require__(46539);
function validateAndParseAddress(address) {
  try {
    const checksummedAddress = (0, import_address.getAddress)(address);
    (0, import_tiny_warning.default)(address === checksummedAddress, `${address} is not checksummed.`);
    return checksummedAddress;
  } catch (error) {
    (0, import_tiny_invariant.default)(false, `${address} is not a valid address.`);
  }
}
function sortedInsert(items, add, maxSize, comparator) {
  (0, import_tiny_invariant.default)(maxSize > 0, "MAX_SIZE_ZERO");
  (0, import_tiny_invariant.default)(items.length <= maxSize, "ITEMS_SIZE");
  if (items.length === 0) {
    items.push(add);
    return null;
  } else {
    const isFull = items.length === maxSize;
    if (isFull && comparator(items[items.length - 1], add) <= 0) {
      return add;
    }
    let lo = 0, hi = items.length;
    while (lo < hi) {
      const mid = lo + hi >>> 1;
      if (comparator(items[mid], add) <= 0) {
        lo = mid + 1;
      } else {
        hi = mid;
      }
    }
    items.splice(lo, 0, add);
    return isFull ? items.pop() : null;
  }
}
function computePriceImpact(midPrice, inputAmount, outputAmount) {
  const quotedOutputAmount = midPrice.quote(inputAmount);
  const priceImpact = quotedOutputAmount.subtract(outputAmount).divide(quotedOutputAmount);
  return new import_swap_sdk_core.Percent(priceImpact.numerator, priceImpact.denominator);
}

// src/entities/token.ts
var ERC20Token = class extends import_swap_sdk_core2.Token {
  constructor(chainId, address, decimals, symbol, name, projectLink) {
    super(chainId, validateAndParseAddress(address), decimals, symbol, name, projectLink);
  }
};

// src/constants.ts
var ChainId = /* @__PURE__ */ ((ChainId2) => {
  ChainId2[ChainId2["ETHEREUM"] = 1] = "ETHEREUM";
  ChainId2[ChainId2["RINKEBY"] = 4] = "RINKEBY";
  ChainId2[ChainId2["GOERLI"] = 5] = "GOERLI";
  ChainId2[ChainId2["BSC"] = 56] = "BSC";
  ChainId2[ChainId2["BSC_TESTNET"] = 8453] = "BSC_TESTNET";
  return ChainId2;
})(ChainId || {});
var FACTORY_ADDRESS = "0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73";
var FACTORY_ADDRESS_ETH = "0x1097053Fd2ea711dad45caCcc45EfF7548fCB362";
var FACTORY_ADDRESS_MAP = {
  [1 /* ETHEREUM */]: FACTORY_ADDRESS_ETH,
  [4 /* RINKEBY */]: FACTORY_ADDRESS_ETH,
  [5 /* GOERLI */]: FACTORY_ADDRESS_ETH,
  [56 /* BSC */]: FACTORY_ADDRESS,
  [8453 /* BSC_TESTNET */]: "0xC0Cd06C6b1Eb550Dcbb8A2414025b379352D530C"
};
var INIT_CODE_HASH = "0x00fb7f630766e6a796048ea87d01acd3068e8ff67d078148a3fa3f4a84f69bd5";
var INIT_CODE_HASH_ETH = "0x57224589c67f3f30a6b0d7a1b54cf3153ab84563bc609ef41dfb34f8b2974d2d";
var INIT_CODE_HASH_MAP = {
  [1 /* ETHEREUM */]: INIT_CODE_HASH_ETH,
  [4 /* RINKEBY */]: INIT_CODE_HASH_ETH,
  [5 /* GOERLI */]: INIT_CODE_HASH_ETH,
  [56 /* BSC */]: INIT_CODE_HASH,
  [8453 /* BSC_TESTNET */]: "0xfeed6e61271f297843ab9183051b7331de901ca9e3509908ffd95e765d55af0c"
};
var WETH9 = {
  [1 /* ETHEREUM */]: new ERC20Token(1 /* ETHEREUM */, "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2", 18, "WETH", "Wrapped Ether", "https://weth.io"),
  [4 /* RINKEBY */]: new ERC20Token(4 /* RINKEBY */, "0xc778417E063141139Fce010982780140Aa0cD5Ab", 18, "WETH", "Wrapped Ether", "https://weth.io"),
  [5 /* GOERLI */]: new ERC20Token(5 /* GOERLI */, "0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6", 18, "WETH", "Wrapped Ether", "https://weth.io")
};
var WBNB = {
  [1 /* ETHEREUM */]: new ERC20Token(1 /* ETHEREUM */, "0x418D75f65a02b3D53B2418FB8E1fe493759c7605", 18, "WBNB", "Wrapped BNB", "https://www.binance.org"),
  [56 /* BSC */]: new ERC20Token(56 /* BSC */, "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c", 18, "WBNB", "Wrapped BNB", "https://www.binance.org"),
  [8453 /* BSC_TESTNET */]: new ERC20Token(8453 /* BSC_TESTNET */, "0x75e09819777137e6928Aa4BC836Ac1EaDB235e79", 18, "WETH", "Wrapped Ether", "https://weth.io")
};
var WNATIVE = {
  [1 /* ETHEREUM */]: WETH9[1 /* ETHEREUM */],
  [4 /* RINKEBY */]: WETH9[4 /* RINKEBY */],
  [5 /* GOERLI */]: WETH9[5 /* GOERLI */],
  [56 /* BSC */]: WBNB[56 /* BSC */],
  [8453 /* BSC_TESTNET */]: WBNB[8453 /* BSC_TESTNET */]
};
var NATIVE = {
  [1 /* ETHEREUM */]: { name: "Ether", symbol: "ETH", decimals: 18 },
  [4 /* RINKEBY */]: { name: "Rinkeby Ether", symbol: "RIN", decimals: 18 },
  [5 /* GOERLI */]: { name: "Goerli Ether", symbol: "GOR", decimals: 18 },
  [56 /* BSC */]: {
    name: "Binance Chain Native Token",
    symbol: "BNB",
    decimals: 18
  },
  [8453 /* BSC_TESTNET */]: {
    name: "Base Chain Native Token",
    symbol: "ETH",
    decimals: 18
  }
};

// src/entities/pair.ts
var import_swap_sdk_core3 = __webpack_require__(46539);
var import_address2 = __webpack_require__(51541);
var import_solidity = __webpack_require__(76693);
var import_jsbi2 = __toESM(__webpack_require__(52424));
var import_tiny_invariant2 = __toESM(__webpack_require__(8780));
var PAIR_ADDRESS_CACHE = {};
var composeKey = (token0, token1) => `${token0.chainId}-${token0.address}-${token1.address}`;
var computePairAddress = ({
  factoryAddress,
  tokenA,
  tokenB
}) => {
  const [token0, token1] = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA];
  const key = composeKey(token0, token1);
  if ((PAIR_ADDRESS_CACHE == null ? void 0 : PAIR_ADDRESS_CACHE[key]) === void 0) {
    PAIR_ADDRESS_CACHE = {
      ...PAIR_ADDRESS_CACHE,
      [key]: (0, import_address2.getCreate2Address)(factoryAddress, (0, import_solidity.keccak256)(["bytes"], [(0, import_solidity.pack)(["address", "address"], [token0.address, token1.address])]), INIT_CODE_HASH_MAP[token0.chainId])
    };
  }
  return PAIR_ADDRESS_CACHE[key];
};
var Pair = class {
  static getAddress(tokenA, tokenB) {
    return computePairAddress({ factoryAddress: FACTORY_ADDRESS_MAP[tokenA.chainId], tokenA, tokenB });
  }
  constructor(currencyAmountA, tokenAmountB) {
    const tokenAmounts = currencyAmountA.currency.sortsBefore(tokenAmountB.currency) ? [currencyAmountA, tokenAmountB] : [tokenAmountB, currencyAmountA];
    this.liquidityToken = new ERC20Token(tokenAmounts[0].currency.chainId, Pair.getAddress(tokenAmounts[0].currency, tokenAmounts[1].currency), 18, "Cake-LP", "Pancake LPs");
    this.tokenAmounts = tokenAmounts;
  }
  involvesToken(token) {
    return token.equals(this.token0) || token.equals(this.token1);
  }
  get token0Price() {
    const result = this.tokenAmounts[1].divide(this.tokenAmounts[0]);
    return new import_swap_sdk_core3.Price(this.token0, this.token1, result.denominator, result.numerator);
  }
  get token1Price() {
    const result = this.tokenAmounts[0].divide(this.tokenAmounts[1]);
    return new import_swap_sdk_core3.Price(this.token1, this.token0, result.denominator, result.numerator);
  }
  priceOf(token) {
    (0, import_tiny_invariant2.default)(this.involvesToken(token), "TOKEN");
    return token.equals(this.token0) ? this.token0Price : this.token1Price;
  }
  get chainId() {
    return this.token0.chainId;
  }
  get token0() {
    return this.tokenAmounts[0].currency;
  }
  get token1() {
    return this.tokenAmounts[1].currency;
  }
  get reserve0() {
    return this.tokenAmounts[0];
  }
  get reserve1() {
    return this.tokenAmounts[1];
  }
  reserveOf(token) {
    (0, import_tiny_invariant2.default)(this.involvesToken(token), "TOKEN");
    return token.equals(this.token0) ? this.reserve0 : this.reserve1;
  }
  getOutputAmount(inputAmount) {
    (0, import_tiny_invariant2.default)(this.involvesToken(inputAmount.currency), "TOKEN");
    if (import_jsbi2.default.equal(this.reserve0.quotient, import_swap_sdk_core3.ZERO) || import_jsbi2.default.equal(this.reserve1.quotient, import_swap_sdk_core3.ZERO)) {
      throw new import_swap_sdk_core3.InsufficientReservesError();
    }
    const inputReserve = this.reserveOf(inputAmount.currency);
    const outputReserve = this.reserveOf(inputAmount.currency.equals(this.token0) ? this.token1 : this.token0);
    const inputAmountWithFee = import_jsbi2.default.multiply(inputAmount.quotient, import_swap_sdk_core3._9975);
    const numerator = import_jsbi2.default.multiply(inputAmountWithFee, outputReserve.quotient);
    const denominator = import_jsbi2.default.add(import_jsbi2.default.multiply(inputReserve.quotient, import_swap_sdk_core3._10000), inputAmountWithFee);
    const outputAmount = import_swap_sdk_core3.CurrencyAmount.fromRawAmount(inputAmount.currency.equals(this.token0) ? this.token1 : this.token0, import_jsbi2.default.divide(numerator, denominator));
    if (import_jsbi2.default.equal(outputAmount.quotient, import_swap_sdk_core3.ZERO)) {
      throw new import_swap_sdk_core3.InsufficientInputAmountError();
    }
    return [outputAmount, new Pair(inputReserve.add(inputAmount), outputReserve.subtract(outputAmount))];
  }
  getInputAmount(outputAmount) {
    (0, import_tiny_invariant2.default)(this.involvesToken(outputAmount.currency), "TOKEN");
    if (import_jsbi2.default.equal(this.reserve0.quotient, import_swap_sdk_core3.ZERO) || import_jsbi2.default.equal(this.reserve1.quotient, import_swap_sdk_core3.ZERO) || import_jsbi2.default.greaterThanOrEqual(outputAmount.quotient, this.reserveOf(outputAmount.currency).quotient)) {
      throw new import_swap_sdk_core3.InsufficientReservesError();
    }
    const outputReserve = this.reserveOf(outputAmount.currency);
    const inputReserve = this.reserveOf(outputAmount.currency.equals(this.token0) ? this.token1 : this.token0);
    const numerator = import_jsbi2.default.multiply(import_jsbi2.default.multiply(inputReserve.quotient, outputAmount.quotient), import_swap_sdk_core3._10000);
    const denominator = import_jsbi2.default.multiply(import_jsbi2.default.subtract(outputReserve.quotient, outputAmount.quotient), import_swap_sdk_core3._9975);
    const inputAmount = import_swap_sdk_core3.CurrencyAmount.fromRawAmount(outputAmount.currency.equals(this.token0) ? this.token1 : this.token0, import_jsbi2.default.add(import_jsbi2.default.divide(numerator, denominator), import_swap_sdk_core3.ONE));
    return [inputAmount, new Pair(inputReserve.add(inputAmount), outputReserve.subtract(outputAmount))];
  }
  getLiquidityMinted(totalSupply, tokenAmountA, tokenAmountB) {
    (0, import_tiny_invariant2.default)(totalSupply.currency.equals(this.liquidityToken), "LIQUIDITY");
    const tokenAmounts = tokenAmountA.currency.sortsBefore(tokenAmountB.currency) ? [tokenAmountA, tokenAmountB] : [tokenAmountB, tokenAmountA];
    (0, import_tiny_invariant2.default)(tokenAmounts[0].currency.equals(this.token0) && tokenAmounts[1].currency.equals(this.token1), "TOKEN");
    let liquidity;
    if (import_jsbi2.default.equal(totalSupply.quotient, import_swap_sdk_core3.ZERO)) {
      liquidity = import_jsbi2.default.subtract((0, import_swap_sdk_core3.sqrt)(import_jsbi2.default.multiply(tokenAmounts[0].quotient, tokenAmounts[1].quotient)), import_swap_sdk_core3.MINIMUM_LIQUIDITY);
    } else {
      const amount0 = import_jsbi2.default.divide(import_jsbi2.default.multiply(tokenAmounts[0].quotient, totalSupply.quotient), this.reserve0.quotient);
      const amount1 = import_jsbi2.default.divide(import_jsbi2.default.multiply(tokenAmounts[1].quotient, totalSupply.quotient), this.reserve1.quotient);
      liquidity = import_jsbi2.default.lessThanOrEqual(amount0, amount1) ? amount0 : amount1;
    }
    if (!import_jsbi2.default.greaterThan(liquidity, import_swap_sdk_core3.ZERO)) {
      throw new import_swap_sdk_core3.InsufficientInputAmountError();
    }
    return import_swap_sdk_core3.CurrencyAmount.fromRawAmount(this.liquidityToken, liquidity);
  }
  getLiquidityValue(token, totalSupply, liquidity, feeOn = false, kLast) {
    (0, import_tiny_invariant2.default)(this.involvesToken(token), "TOKEN");
    (0, import_tiny_invariant2.default)(totalSupply.currency.equals(this.liquidityToken), "TOTAL_SUPPLY");
    (0, import_tiny_invariant2.default)(liquidity.currency.equals(this.liquidityToken), "LIQUIDITY");
    (0, import_tiny_invariant2.default)(import_jsbi2.default.lessThanOrEqual(liquidity.quotient, totalSupply.quotient), "LIQUIDITY");
    let totalSupplyAdjusted;
    if (!feeOn) {
      totalSupplyAdjusted = totalSupply;
    } else {
      (0, import_tiny_invariant2.default)(!!kLast, "K_LAST");
      const kLastParsed = import_jsbi2.default.BigInt(kLast);
      if (!import_jsbi2.default.equal(kLastParsed, import_swap_sdk_core3.ZERO)) {
        const rootK = (0, import_swap_sdk_core3.sqrt)(import_jsbi2.default.multiply(this.reserve0.quotient, this.reserve1.quotient));
        const rootKLast = (0, import_swap_sdk_core3.sqrt)(kLastParsed);
        if (import_jsbi2.default.greaterThan(rootK, rootKLast)) {
          const numerator = import_jsbi2.default.multiply(totalSupply.quotient, import_jsbi2.default.subtract(rootK, rootKLast));
          const denominator = import_jsbi2.default.add(import_jsbi2.default.multiply(rootK, import_swap_sdk_core3.FIVE), rootKLast);
          const feeLiquidity = import_jsbi2.default.divide(numerator, denominator);
          totalSupplyAdjusted = totalSupply.add(import_swap_sdk_core3.CurrencyAmount.fromRawAmount(this.liquidityToken, feeLiquidity));
        } else {
          totalSupplyAdjusted = totalSupply;
        }
      } else {
        totalSupplyAdjusted = totalSupply;
      }
    }
    return import_swap_sdk_core3.CurrencyAmount.fromRawAmount(token, import_jsbi2.default.divide(import_jsbi2.default.multiply(liquidity.quotient, this.reserveOf(token).quotient), totalSupplyAdjusted.quotient));
  }
};

// src/entities/route.ts
var import_tiny_invariant3 = __toESM(__webpack_require__(8780));
var import_swap_sdk_core4 = __webpack_require__(46539);
var Route = class {
  constructor(pairs, input, output) {
    this._midPrice = null;
    (0, import_tiny_invariant3.default)(pairs.length > 0, "PAIRS");
    const chainId = pairs[0].chainId;
    (0, import_tiny_invariant3.default)(pairs.every((pair) => pair.chainId === chainId), "CHAIN_IDS");
    const wrappedInput = input.wrapped;
    (0, import_tiny_invariant3.default)(pairs[0].involvesToken(wrappedInput), "INPUT");
    (0, import_tiny_invariant3.default)(typeof output === "undefined" || pairs[pairs.length - 1].involvesToken(output.wrapped), "OUTPUT");
    const path = [wrappedInput];
    for (const [i, pair] of pairs.entries()) {
      const currentInput = path[i];
      (0, import_tiny_invariant3.default)(currentInput.equals(pair.token0) || currentInput.equals(pair.token1), "PATH");
      const output2 = currentInput.equals(pair.token0) ? pair.token1 : pair.token0;
      path.push(output2);
    }
    this.pairs = pairs;
    this.path = path;
    this.input = input;
    this.output = output;
  }
  get midPrice() {
    if (this._midPrice !== null)
      return this._midPrice;
    const prices = [];
    for (const [i, pair] of this.pairs.entries()) {
      prices.push(this.path[i].equals(pair.token0) ? new import_swap_sdk_core4.Price(pair.reserve0.currency, pair.reserve1.currency, pair.reserve0.quotient, pair.reserve1.quotient) : new import_swap_sdk_core4.Price(pair.reserve1.currency, pair.reserve0.currency, pair.reserve1.quotient, pair.reserve0.quotient));
    }
    const reduced = prices.slice(1).reduce((accumulator, currentValue) => accumulator.multiply(currentValue), prices[0]);
    return this._midPrice = new import_swap_sdk_core4.Price(this.input, this.output, reduced.denominator, reduced.numerator);
  }
  get chainId() {
    return this.pairs[0].chainId;
  }
};

// src/entities/trade.ts
var import_tiny_invariant4 = __toESM(__webpack_require__(8780));
var import_swap_sdk_core5 = __webpack_require__(46539);
function inputOutputComparator(a, b) {
  (0, import_tiny_invariant4.default)(a.inputAmount.currency.equals(b.inputAmount.currency), "INPUT_CURRENCY");
  (0, import_tiny_invariant4.default)(a.outputAmount.currency.equals(b.outputAmount.currency), "OUTPUT_CURRENCY");
  if (a.outputAmount.equalTo(b.outputAmount)) {
    if (a.inputAmount.equalTo(b.inputAmount)) {
      return 0;
    }
    if (a.inputAmount.lessThan(b.inputAmount)) {
      return -1;
    } else {
      return 1;
    }
  } else {
    if (a.outputAmount.lessThan(b.outputAmount)) {
      return 1;
    } else {
      return -1;
    }
  }
}
function tradeComparator(a, b) {
  const ioComp = inputOutputComparator(a, b);
  if (ioComp !== 0) {
    return ioComp;
  }
  if (a.priceImpact.lessThan(b.priceImpact)) {
    return -1;
  } else if (a.priceImpact.greaterThan(b.priceImpact)) {
    return 1;
  }
  return a.route.path.length - b.route.path.length;
}
var Trade = class {
  static exactIn(route, amountIn) {
    return new Trade(route, amountIn, import_swap_sdk_core5.TradeType.EXACT_INPUT);
  }
  static exactOut(route, amountOut) {
    return new Trade(route, amountOut, import_swap_sdk_core5.TradeType.EXACT_OUTPUT);
  }
  constructor(route, amount, tradeType) {
    this.route = route;
    this.tradeType = tradeType;
    const tokenAmounts = new Array(route.path.length);
    if (tradeType === import_swap_sdk_core5.TradeType.EXACT_INPUT) {
      (0, import_tiny_invariant4.default)(amount.currency.equals(route.input), "INPUT");
      tokenAmounts[0] = amount.wrapped;
      for (let i = 0; i < route.path.length - 1; i++) {
        const pair = route.pairs[i];
        const [outputAmount] = pair.getOutputAmount(tokenAmounts[i]);
        tokenAmounts[i + 1] = outputAmount;
      }
      this.inputAmount = import_swap_sdk_core5.CurrencyAmount.fromFractionalAmount(route.input, amount.numerator, amount.denominator);
      this.outputAmount = import_swap_sdk_core5.CurrencyAmount.fromFractionalAmount(route.output, tokenAmounts[tokenAmounts.length - 1].numerator, tokenAmounts[tokenAmounts.length - 1].denominator);
    } else {
      (0, import_tiny_invariant4.default)(amount.currency.equals(route.output), "OUTPUT");
      tokenAmounts[tokenAmounts.length - 1] = amount.wrapped;
      for (let i = route.path.length - 1; i > 0; i--) {
        const pair = route.pairs[i - 1];
        const [inputAmount] = pair.getInputAmount(tokenAmounts[i]);
        tokenAmounts[i - 1] = inputAmount;
      }
      this.inputAmount = import_swap_sdk_core5.CurrencyAmount.fromFractionalAmount(route.input, tokenAmounts[0].numerator, tokenAmounts[0].denominator);
      this.outputAmount = import_swap_sdk_core5.CurrencyAmount.fromFractionalAmount(route.output, amount.numerator, amount.denominator);
    }
    this.executionPrice = new import_swap_sdk_core5.Price(this.inputAmount.currency, this.outputAmount.currency, this.inputAmount.quotient, this.outputAmount.quotient);
    this.priceImpact = computePriceImpact(route.midPrice, this.inputAmount, this.outputAmount);
  }
  minimumAmountOut(slippageTolerance) {
    (0, import_tiny_invariant4.default)(!slippageTolerance.lessThan(import_swap_sdk_core5.ZERO), "SLIPPAGE_TOLERANCE");
    if (this.tradeType === import_swap_sdk_core5.TradeType.EXACT_OUTPUT) {
      return this.outputAmount;
    } else {
      const slippageAdjustedAmountOut = new import_swap_sdk_core5.Fraction(import_swap_sdk_core5.ONE).add(slippageTolerance).invert().multiply(this.outputAmount.quotient).quotient;
      return import_swap_sdk_core5.CurrencyAmount.fromRawAmount(this.outputAmount.currency, slippageAdjustedAmountOut);
    }
  }
  maximumAmountIn(slippageTolerance) {
    (0, import_tiny_invariant4.default)(!slippageTolerance.lessThan(import_swap_sdk_core5.ZERO), "SLIPPAGE_TOLERANCE");
    if (this.tradeType === import_swap_sdk_core5.TradeType.EXACT_INPUT) {
      return this.inputAmount;
    } else {
      const slippageAdjustedAmountIn = new import_swap_sdk_core5.Fraction(import_swap_sdk_core5.ONE).add(slippageTolerance).multiply(this.inputAmount.quotient).quotient;
      return import_swap_sdk_core5.CurrencyAmount.fromRawAmount(this.inputAmount.currency, slippageAdjustedAmountIn);
    }
  }
  static bestTradeExactIn(pairs, currencyAmountIn, currencyOut, { maxNumResults = 3, maxHops = 3 } = {}, currentPairs = [], nextAmountIn = currencyAmountIn, bestTrades = []) {
    (0, import_tiny_invariant4.default)(pairs.length > 0, "PAIRS");
    (0, import_tiny_invariant4.default)(maxHops > 0, "MAX_HOPS");
    (0, import_tiny_invariant4.default)(currencyAmountIn === nextAmountIn || currentPairs.length > 0, "INVALID_RECURSION");
    const amountIn = nextAmountIn.wrapped;
    const tokenOut = currencyOut.wrapped;
    for (let i = 0; i < pairs.length; i++) {
      const pair = pairs[i];
      if (!pair.token0.equals(amountIn.currency) && !pair.token1.equals(amountIn.currency))
        continue;
      if (pair.reserve0.equalTo(import_swap_sdk_core5.ZERO) || pair.reserve1.equalTo(import_swap_sdk_core5.ZERO))
        continue;
      let amountOut;
      try {
        ;
        [amountOut] = pair.getOutputAmount(amountIn);
      } catch (error) {
        if (error.isInsufficientInputAmountError) {
          continue;
        }
        throw error;
      }
      if (amountOut.currency.equals(tokenOut)) {
        sortedInsert(bestTrades, new Trade(new Route([...currentPairs, pair], currencyAmountIn.currency, currencyOut), currencyAmountIn, import_swap_sdk_core5.TradeType.EXACT_INPUT), maxNumResults, tradeComparator);
      } else if (maxHops > 1 && pairs.length > 1) {
        const pairsExcludingThisPair = pairs.slice(0, i).concat(pairs.slice(i + 1, pairs.length));
        Trade.bestTradeExactIn(pairsExcludingThisPair, currencyAmountIn, currencyOut, {
          maxNumResults,
          maxHops: maxHops - 1
        }, [...currentPairs, pair], amountOut, bestTrades);
      }
    }
    return bestTrades;
  }
  worstExecutionPrice(slippageTolerance) {
    return new import_swap_sdk_core5.Price(this.inputAmount.currency, this.outputAmount.currency, this.maximumAmountIn(slippageTolerance).quotient, this.minimumAmountOut(slippageTolerance).quotient);
  }
  static bestTradeExactOut(pairs, currencyIn, currencyAmountOut, { maxNumResults = 3, maxHops = 3 } = {}, currentPairs = [], nextAmountOut = currencyAmountOut, bestTrades = []) {
    (0, import_tiny_invariant4.default)(pairs.length > 0, "PAIRS");
    (0, import_tiny_invariant4.default)(maxHops > 0, "MAX_HOPS");
    (0, import_tiny_invariant4.default)(currencyAmountOut === nextAmountOut || currentPairs.length > 0, "INVALID_RECURSION");
    const amountOut = nextAmountOut.wrapped;
    const tokenIn = currencyIn.wrapped;
    for (let i = 0; i < pairs.length; i++) {
      const pair = pairs[i];
      if (!pair.token0.equals(amountOut.currency) && !pair.token1.equals(amountOut.currency))
        continue;
      if (pair.reserve0.equalTo(import_swap_sdk_core5.ZERO) || pair.reserve1.equalTo(import_swap_sdk_core5.ZERO))
        continue;
      let amountIn;
      try {
        ;
        [amountIn] = pair.getInputAmount(amountOut);
      } catch (error) {
        if (error.isInsufficientReservesError) {
          continue;
        }
        throw error;
      }
      if (amountIn.currency.equals(tokenIn)) {
        sortedInsert(bestTrades, new Trade(new Route([pair, ...currentPairs], currencyIn, currencyAmountOut.currency), currencyAmountOut, import_swap_sdk_core5.TradeType.EXACT_OUTPUT), maxNumResults, tradeComparator);
      } else if (maxHops > 1 && pairs.length > 1) {
        const pairsExcludingThisPair = pairs.slice(0, i).concat(pairs.slice(i + 1, pairs.length));
        Trade.bestTradeExactOut(pairsExcludingThisPair, currencyIn, currencyAmountOut, {
          maxNumResults,
          maxHops: maxHops - 1
        }, [pair, ...currentPairs], amountIn, bestTrades);
      }
    }
    return bestTrades;
  }
};

// src/entities/native.ts
var import_tiny_invariant5 = __toESM(__webpack_require__(8780));
var import_swap_sdk_core6 = __webpack_require__(46539);
var _Native = class extends import_swap_sdk_core6.NativeCurrency {
  constructor({
    chainId,
    decimals,
    name,
    symbol
  }) {
    super(chainId, decimals, symbol, name);
  }
  get wrapped() {
    const wnative = WNATIVE[this.chainId];
    (0, import_tiny_invariant5.default)(!!wnative, "WRAPPED");
    return wnative;
  }
  static onChain(chainId) {
    if (chainId in this.cache) {
      return this.cache[chainId];
    }
    (0, import_tiny_invariant5.default)(!!NATIVE[chainId], "NATIVE_CURRENCY");
    const { decimals, name, symbol } = NATIVE[chainId];
    return this.cache[chainId] = new _Native({ chainId, decimals, symbol, name });
  }
  equals(other) {
    return other.isNative && other.chainId === this.chainId;
  }
};
var Native = _Native;
Native.cache = {};

// src/router.ts
var import_swap_sdk_core7 = __webpack_require__(46539);
var import_tiny_invariant6 = __toESM(__webpack_require__(8780));
function toHex(currencyAmount) {
  return `0x${currencyAmount.quotient.toString(16)}`;
}
var ZERO_HEX = "0x0";
var Router = class {
  constructor() {
  }
  static swapCallParameters(trade, options) {
    const etherIn = trade.inputAmount.currency.isNative;
    const etherOut = trade.outputAmount.currency.isNative;
    (0, import_tiny_invariant6.default)(!(etherIn && etherOut), "ETHER_IN_OUT");
    (0, import_tiny_invariant6.default)(!("ttl" in options) || options.ttl > 0, "TTL");
    const to = validateAndParseAddress(options.recipient);
    const amountIn = toHex(trade.maximumAmountIn(options.allowedSlippage));
    const amountOut = toHex(trade.minimumAmountOut(options.allowedSlippage));
    const path = trade.route.path.map((token) => token.address);
    const deadline = "ttl" in options ? `0x${(Math.floor(new Date().getTime() / 1e3) + options.ttl).toString(16)}` : `0x${options.deadline.toString(16)}`;
    const useFeeOnTransfer = Boolean(options.feeOnTransfer);
    let methodName;
    let args;
    let value;
    switch (trade.tradeType) {
      case import_swap_sdk_core7.TradeType.EXACT_INPUT:
        if (etherIn) {
          methodName = useFeeOnTransfer ? "swapExactETHForTokensSupportingFeeOnTransferTokens" : "swapExactETHForTokens";
          args = [amountOut, path, to, deadline];
          value = amountIn;
        } else if (etherOut) {
          methodName = useFeeOnTransfer ? "swapExactTokensForETHSupportingFeeOnTransferTokens" : "swapExactTokensForETH";
          args = [amountIn, amountOut, path, to, deadline];
          value = ZERO_HEX;
        } else {
          methodName = useFeeOnTransfer ? "swapExactTokensForTokensSupportingFeeOnTransferTokens" : "swapExactTokensForTokens";
          args = [amountIn, amountOut, path, to, deadline];
          value = ZERO_HEX;
        }
        break;
      case import_swap_sdk_core7.TradeType.EXACT_OUTPUT:
        (0, import_tiny_invariant6.default)(!useFeeOnTransfer, "EXACT_OUT_FOT");
        if (etherIn) {
          methodName = "swapETHForExactTokens";
          args = [amountOut, path, to, deadline];
          value = amountIn;
        } else if (etherOut) {
          methodName = "swapTokensForExactETH";
          args = [amountOut, amountIn, path, to, deadline];
          value = ZERO_HEX;
        } else {
          methodName = "swapTokensForExactTokens";
          args = [amountOut, amountIn, path, to, deadline];
          value = ZERO_HEX;
        }
        break;
    }
    return {
      methodName,
      args,
      value
    };
  }
};

// src/index.ts
__reExport(src_exports, __webpack_require__(46539), module.exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (0);


/***/ }),

/***/ 9270:
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FL": () => (/* binding */ WagmiProvider),
/* harmony export */   "Ge": () => (/* binding */ useWeb3React),
/* harmony export */   "Hp": () => (/* binding */ useWeb3LibraryContext),
/* harmony export */   "QW": () => (/* binding */ useSignMessage)
/* harmony export */ });
/* harmony import */ var _ethersproject_providers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(90399);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(16689);
/* harmony import */ var swr_immutable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(79847);
/* harmony import */ var wagmi__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8906);
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([swr_immutable__WEBPACK_IMPORTED_MODULE_2__]);
swr_immutable__WEBPACK_IMPORTED_MODULE_2__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];
// src/provider.tsx




function WagmiProvider(props) {
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(wagmi__WEBPACK_IMPORTED_MODULE_3__.WagmiConfig, {
    client: props.client
  }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(Web3LibraryProvider, null, props.children));
}
var Web3LibraryContext = react__WEBPACK_IMPORTED_MODULE_1__.createContext(void 0);
var useWeb3LibraryContext = () => {
  return react__WEBPACK_IMPORTED_MODULE_1__.useContext(Web3LibraryContext);
};
var Web3LibraryProvider = (props) => {
  const { connector } = (0,wagmi__WEBPACK_IMPORTED_MODULE_3__.useAccount)();
  const { chain } = (0,wagmi__WEBPACK_IMPORTED_MODULE_3__.useNetwork)();
  const { data: library } = (0,swr_immutable__WEBPACK_IMPORTED_MODULE_2__["default"])(connector && ["web3-library", connector, chain], async () => {
    const provider = await (connector == null ? void 0 : connector.getProvider());
    return new _ethersproject_providers__WEBPACK_IMPORTED_MODULE_0__.Web3Provider(provider);
  });
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(Web3LibraryContext.Provider, {
    value: library
  }, props.children);
};

// src/useWeb3React.ts

function useWeb3React() {
  const { chain } = (0,wagmi__WEBPACK_IMPORTED_MODULE_3__.useNetwork)();
  const { address, connector, isConnected, isConnecting } = (0,wagmi__WEBPACK_IMPORTED_MODULE_3__.useAccount)();
  return {
    chainId: chain == null ? void 0 : chain.id,
    account: isConnected ? address : null,
    isConnected,
    isConnecting,
    chain,
    connector
  };
}

// src/hooks/useSignMessage.ts


function useSignMessage() {
  const { address, connector } = (0,wagmi__WEBPACK_IMPORTED_MODULE_3__.useAccount)();
  const { signMessageAsync: sign } = (0,wagmi__WEBPACK_IMPORTED_MODULE_3__.useSignMessage)();
  return {
    signMessageAsync: (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(async (args) => {
      var _a, _b;
      if ((connector == null ? void 0 : connector.id) === "bsc" && window.BinanceChain && address) {
        const res = await ((_b = (_a = window.BinanceChain).bnbSign) == null ? void 0 : _b.call(_a, address, args.message));
        if (res) {
          return res.signature;
        }
        return null;
      }
      return sign(args);
    }, [address, connector == null ? void 0 : connector.id, sign])
  };
}


__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ })

};
;
//# sourceMappingURL=9660.js.map